"use strict";(globalThis.webpackChunkq4_hackathon=globalThis.webpackChunkq4_hackathon||[]).push([[7795],{8416:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module2-gazebo-unity/lesson1-digital-twin-concepts","title":"Lesson 1 - Digital Twin Concepts and Simulation","description":"Overview","source":"@site/docs/module2-gazebo-unity/lesson1-digital-twin-concepts.md","sourceDirName":"module2-gazebo-unity","slug":"/module2-gazebo-unity/lesson1-digital-twin-concepts","permalink":"/Q4-hackathon1/docs/module2-gazebo-unity/lesson1-digital-twin-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/iffatmumtaz/Q4-hackathon1/edit/main/docs/module2-gazebo-unity/lesson1-digital-twin-concepts.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Digital Twin Concepts","title":"Lesson 1 - Digital Twin Concepts and Simulation"},"sidebar":"tutorialSidebar","previous":{"title":"Actions and Services","permalink":"/Q4-hackathon1/docs/module1-ros2/lesson3-ros2-actions-services"},"next":{"title":"Gazebo Simulation Environments","permalink":"/Q4-hackathon1/docs/module2-gazebo-unity/lesson2-gazebo-simulations"}}');var s=e(4848),a=e(8453);const l={sidebar_label:"Digital Twin Concepts",title:"Lesson 1 - Digital Twin Concepts and Simulation"},o="Lesson 1: Introduction to Digital Twin Concepts and Simulation",r={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Goals",id:"learning-goals",level:2},{value:"Concepts",id:"concepts",level:2},{value:"What is a Digital Twin?",id:"what-is-a-digital-twin",level:3},{value:"Key Components of a Digital Twin System:",id:"key-components-of-a-digital-twin-system",level:3},{value:"Digital Twins in Robotics:",id:"digital-twins-in-robotics",level:3},{value:"Steps",id:"steps",level:2},{value:"Step 1: Understanding Digital Twin Architecture",id:"step-1-understanding-digital-twin-architecture",level:3},{value:"Step 2: Setting Up a Simple Digital Twin Concept",id:"step-2-setting-up-a-simple-digital-twin-concept",level:3},{value:"Step 3: Connecting to Simulation Environment",id:"step-3-connecting-to-simulation-environment",level:3},{value:"Step 4: Real-time Synchronization",id:"step-4-real-time-synchronization",level:3},{value:"Code",id:"code",level:2},{value:"Complete Digital Twin with ROS 2 Integration:",id:"complete-digital-twin-with-ros-2-integration",level:3},{value:"Examples",id:"examples",level:2},{value:"Digital Twin in Different Scenarios:",id:"digital-twin-in-different-scenarios",level:3},{value:"Using Gazebo as a Digital Twin Platform:",id:"using-gazebo-as-a-digital-twin-platform",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Required Tools &amp; Software",id:"required-tools--software",level:2},{value:"Expected Outcome",id:"expected-outcome",level:2}];function d(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"lesson-1-introduction-to-digital-twin-concepts-and-simulation",children:"Lesson 1: Introduction to Digital Twin Concepts and Simulation"})}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.p,{children:"This lesson introduces the concept of digital twins in robotics and their crucial role in developing, testing, and validating robotic systems. You'll learn how digital twins bridge the gap between simulation and reality, enabling safer and more efficient robot development."}),"\n",(0,s.jsx)(i.h2,{id:"learning-goals",children:"Learning Goals"}),"\n",(0,s.jsx)(i.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Define digital twin concepts and their applications in robotics"}),"\n",(0,s.jsx)(i.li,{children:"Understand the benefits and limitations of digital twin technology"}),"\n",(0,s.jsx)(i.li,{children:"Explain the relationship between simulation and physical robots"}),"\n",(0,s.jsx)(i.li,{children:"Identify scenarios where digital twins are most beneficial"}),"\n",(0,s.jsx)(i.li,{children:"Recognize the key components of a digital twin system"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"concepts",children:"Concepts"}),"\n",(0,s.jsx)(i.h3,{id:"what-is-a-digital-twin",children:"What is a Digital Twin?"}),"\n",(0,s.jsx)(i.p,{children:"A digital twin is a virtual representation of a physical object or system that spans its lifecycle, is updated with real-time data, and uses simulation, machine learning, and reasoning to help decision-making."}),"\n",(0,s.jsx)(i.h3,{id:"key-components-of-a-digital-twin-system",children:"Key Components of a Digital Twin System:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Physical Twin"}),": The actual physical system or robot"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Virtual Twin"}),": The digital model that mirrors the physical system"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Connection"}),": The data flow between physical and virtual twins"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Data"}),": Real-time and historical information that drives the twin"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Analytics"}),": Algorithms that process data to provide insights"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"digital-twins-in-robotics",children:"Digital Twins in Robotics:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Design Phase"}),": Simulate robot behavior before physical construction"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Development Phase"}),": Test algorithms and control systems in simulation"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Testing Phase"}),": Validate safety and performance in virtual environments"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Deployment Phase"}),": Monitor and optimize physical robots using digital models"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Maintenance Phase"}),": Predict failures and optimize performance"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"steps",children:"Steps"}),"\n",(0,s.jsx)(i.h3,{id:"step-1-understanding-digital-twin-architecture",children:"Step 1: Understanding Digital Twin Architecture"}),"\n",(0,s.jsx)(i.p,{children:"The digital twin architecture in robotics typically consists of:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Physical Robot"}),": Real hardware with sensors and actuators"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Data Collection Layer"}),": Sensors gathering real-time data"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Communication Layer"}),": Network protocols transferring data"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Virtual Model"}),": Simulation environment (Gazebo, Unity, etc.)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Analytics Engine"}),": Processing algorithms for insights"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Visualization Layer"}),": User interfaces for monitoring and control"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"step-2-setting-up-a-simple-digital-twin-concept",children:"Step 2: Setting Up a Simple Digital Twin Concept"}),"\n",(0,s.jsx)(i.p,{children:"Let's explore the concept with a simple example:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'# digital_twin_example.py\nimport time\nimport math\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass\nclass RobotState:\n    """Represents the state of a physical robot"""\n    x: float\n    y: float\n    theta: float  # orientation\n    velocity: float\n    timestamp: float\n\n\nclass DigitalTwin:\n    """A simple digital twin for a robot"""\n\n    def __init__(self, name: str):\n        self.name = name\n        self.physical_state: Optional[RobotState] = None\n        self.virtual_state: Optional[RobotState] = None\n        self.simulation_time = 0.0\n\n    def update_from_physical(self, physical_state: RobotState):\n        """Update the digital twin with data from the physical robot"""\n        self.physical_state = physical_state\n        self.sync_virtual_to_physical()\n        print(f"Digital twin {self.name} updated from physical robot")\n\n    def sync_virtual_to_physical(self):\n        """Synchronize virtual model with physical state"""\n        if self.physical_state:\n            # In a real system, this would update the simulation\n            self.virtual_state = RobotState(\n                x=self.physical_state.x,\n                y=self.physical_state.y,\n                theta=self.physical_state.theta,\n                velocity=self.physical_state.velocity,\n                timestamp=self.physical_state.timestamp\n            )\n\n    def predict_behavior(self, time_ahead: float) -> RobotState:\n        """Predict future state based on current state"""\n        if not self.virtual_state:\n            raise ValueError("Virtual state not initialized")\n\n        # Simple prediction: assume constant velocity motion\n        dt = time_ahead\n        new_x = self.virtual_state.x + self.virtual_state.velocity * dt * math.cos(self.virtual_state.theta)\n        new_y = self.virtual_state.y + self.virtual_state.velocity * dt * math.sin(self.virtual_state.theta)\n        new_theta = self.virtual_state.theta  # Assume no rotation for simplicity\n        new_velocity = self.virtual_state.velocity\n\n        return RobotState(\n            x=new_x,\n            y=new_y,\n            theta=new_theta,\n            velocity=new_velocity,\n            timestamp=self.virtual_state.timestamp + dt\n        )\n\n    def simulate_behavior(self, control_input: dict):\n        """Simulate robot behavior based on control inputs"""\n        if not self.virtual_state:\n            return\n\n        # Apply control logic to update virtual state\n        # This is where simulation physics would be applied\n        print(f"Simulating behavior for {self.name} with control: {control_input}")\n\n\ndef main():\n    # Create a digital twin instance\n    robot_twin = DigitalTwin("TestRobot")\n\n    # Simulate receiving data from a physical robot\n    physical_state = RobotState(\n        x=1.0, y=2.0, theta=0.5, velocity=0.5, timestamp=time.time()\n    )\n\n    # Update the digital twin\n    robot_twin.update_from_physical(physical_state)\n\n    # Predict future state\n    future_state = robot_twin.predict_behavior(time_ahead=2.0)\n    print(f"Predicted state: ({future_state.x:.2f}, {future_state.y:.2f})")\n\n    # Simulate behavior with control input\n    robot_twin.simulate_behavior({"command": "move_forward", "speed": 0.3})\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,s.jsx)(i.h3,{id:"step-3-connecting-to-simulation-environment",children:"Step 3: Connecting to Simulation Environment"}),"\n",(0,s.jsx)(i.p,{children:"In a real robotics application, you would connect your digital twin to a simulation environment like Gazebo or Unity:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"# Example: Launch Gazebo with a robot model\n# This would typically be done through ROS 2 launch files\nros2 launch gazebo_ros empty_world.launch.py\n"})}),"\n",(0,s.jsx)(i.h3,{id:"step-4-real-time-synchronization",children:"Step 4: Real-time Synchronization"}),"\n",(0,s.jsx)(i.p,{children:"The key challenge in digital twins is maintaining synchronization between physical and virtual systems:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import threading\nimport queue\n\n\nclass SynchronizedDigitalTwin:\n    """A digital twin with real-time synchronization"""\n\n    def __init__(self, name: str):\n        self.name = name\n        self.data_queue = queue.Queue()\n        self.sync_thread = None\n        self.running = False\n\n    def start_synchronization(self):\n        """Start the synchronization thread"""\n        self.running = True\n        self.sync_thread = threading.Thread(target=self._sync_loop)\n        self.sync_thread.start()\n\n    def stop_synchronization(self):\n        """Stop the synchronization"""\n        self.running = False\n        if self.sync_thread:\n            self.sync_thread.join()\n\n    def _sync_loop(self):\n        """Internal synchronization loop"""\n        while self.running:\n            try:\n                # Get new data from physical system\n                data = self.data_queue.get(timeout=1.0)\n                self._process_physical_data(data)\n            except queue.Empty:\n                continue  # Check if still running\n\n    def _process_physical_data(self, data):\n        """Process data from the physical system"""\n        print(f"Processing physical data: {data}")\n        # Update virtual model based on physical data\n        # Run simulation predictions\n        # Generate insights or alerts\n'})}),"\n",(0,s.jsx)(i.h2,{id:"code",children:"Code"}),"\n",(0,s.jsx)(i.h3,{id:"complete-digital-twin-with-ros-2-integration",children:"Complete Digital Twin with ROS 2 Integration:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Twist\nfrom nav_msgs.msg import Odometry\nfrom std_msgs.msg import String\nimport time\nfrom typing import Dict, Any\n\n\nclass RobotDigitalTwin(Node):\n    \"\"\"A digital twin node that synchronizes with a physical robot\"\"\"\n\n    def __init__(self):\n        super().__init__('robot_digital_twin')\n\n        # Publishers for virtual robot state\n        self.odom_publisher = self.create_publisher(Odometry, 'virtual_robot/odom', 10)\n        self.joint_state_publisher = self.create_publisher(JointState, 'virtual_robot/joint_states', 10)\n\n        # Subscribers for physical robot state\n        self.physical_odom_sub = self.create_subscription(\n            Odometry, 'physical_robot/odom', self.physical_odom_callback, 10)\n        self.physical_joint_sub = self.create_subscription(\n            JointState, 'physical_robot/joint_states', self.physical_joint_callback, 10)\n\n        # Timer for publishing virtual state\n        self.timer = self.create_timer(0.1, self.publish_virtual_state)  # 10 Hz\n\n        # State tracking\n        self.physical_odom = None\n        self.physical_joint_states = None\n        self.last_sync_time = self.get_clock().now()\n\n        self.get_logger().info('Robot digital twin initialized')\n\n    def physical_odom_callback(self, msg: Odometry):\n        \"\"\"Receive odometry from physical robot\"\"\"\n        self.physical_odom = msg\n        self.last_sync_time = self.get_clock().now()\n        self.get_logger().debug('Received physical odometry')\n\n    def physical_joint_callback(self, msg: JointState):\n        \"\"\"Receive joint states from physical robot\"\"\"\n        self.physical_joint_states = msg\n        self.get_logger().debug('Received physical joint states')\n\n    def publish_virtual_state(self):\n        \"\"\"Publish synchronized virtual robot state\"\"\"\n        if self.physical_odom:\n            # Create virtual odometry (could include predictions)\n            virtual_odom = Odometry()\n            virtual_odom.header.stamp = self.get_clock().now().to_msg()\n            virtual_odom.header.frame_id = 'virtual_odom'\n            virtual_odom.child_frame_id = 'virtual_base_link'\n\n            # Copy position from physical robot with potential adjustments\n            virtual_odom.pose.pose = self.physical_odom.pose.pose\n            virtual_odom.twist.twist = self.physical_odom.twist.twist\n\n            self.odom_publisher.publish(virtual_odom)\n\n        if self.physical_joint_states:\n            # Publish virtual joint states\n            virtual_joints = JointState()\n            virtual_joints.header.stamp = self.get_clock().now().to_msg()\n            virtual_joints.name = self.physical_joint_states.name\n            virtual_joints.position = self.physical_joint_states.position\n            virtual_joints.velocity = self.physical_joint_states.velocity\n            virtual_joints.effort = self.physical_joint_states.effort\n\n            self.joint_state_publisher.publish(virtual_joints)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    twin_node = RobotDigitalTwin()\n\n    try:\n        rclpy.spin(twin_node)\n    except KeyboardInterrupt:\n        twin_node.get_logger().info('Digital twin interrupted by user')\n    finally:\n        twin_node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(i.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(i.h3,{id:"digital-twin-in-different-scenarios",children:"Digital Twin in Different Scenarios:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Manufacturing Robot"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Physical: Assembly robot on a production line"}),"\n",(0,s.jsx)(i.li,{children:"Virtual: Simulation of the same robot performing tasks"}),"\n",(0,s.jsx)(i.li,{children:"Benefits: Predictive maintenance, optimization, safety validation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Autonomous Vehicle"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Physical: Self-driving car on the road"}),"\n",(0,s.jsx)(i.li,{children:"Virtual: Simulation of the vehicle in various conditions"}),"\n",(0,s.jsx)(i.li,{children:"Benefits: Testing in dangerous scenarios, scenario planning"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Medical Robot"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Physical: Surgical robot in an operating room"}),"\n",(0,s.jsx)(i.li,{children:"Virtual: Simulation for training and procedure planning"}),"\n",(0,s.jsx)(i.li,{children:"Benefits: Training, risk assessment, procedure optimization"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"using-gazebo-as-a-digital-twin-platform",children:"Using Gazebo as a Digital Twin Platform:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"# Launch a robot simulation in Gazebo\nros2 launch my_robot_gazebo my_robot_world.launch.py\n\n# The simulation can mirror the physical robot's behavior\n# and be used for testing new control algorithms safely\n"})}),"\n",(0,s.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Maintain Accurate Models"}),": Ensure your virtual model accurately reflects the physical system"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Real-time Synchronization"}),": Minimize latency between physical and virtual systems"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Data Quality"}),": Use reliable sensors and communication protocols"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Model Validation"}),": Regularly validate that the digital twin accurately represents reality"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Security"}),": Protect the communication channels between physical and virtual systems"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Scalability"}),": Design systems that can handle multiple digital twins"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Analytics Integration"}),": Use the digital twin for predictive analytics and insights"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Version Control"}),": Keep track of model versions and changes over time"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"required-tools--software",children:"Required Tools & Software"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Simulation Environment"}),": Gazebo, Unity Robotics, NVIDIA Isaac Sim, or Webots"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"ROS 2"}),": For communication between physical and virtual systems"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Programming Language"}),": Python or C++ for custom twin logic"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Visualization Tools"}),": RViz, custom dashboards, or simulation GUIs"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Sensors"}),": For collecting real-time data from physical systems"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Network Infrastructure"}),": For reliable data transmission"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"expected-outcome",children:"Expected Outcome"}),"\n",(0,s.jsx)(i.p,{children:"After completing this lesson, you should:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Understand the concept and applications of digital twins in robotics"}),"\n",(0,s.jsx)(i.li,{children:"Be able to design simple digital twin architectures"}),"\n",(0,s.jsx)(i.li,{children:"Recognize the benefits and challenges of digital twin implementation"}),"\n",(0,s.jsx)(i.li,{children:"Know how to connect physical robots to simulation environments"}),"\n",(0,s.jsx)(i.li,{children:"Have a foundation for implementing more complex digital twin systems"}),"\n"]})]})}function h(n={}){const{wrapper:i}={...(0,a.R)(),...n.components};return i?(0,s.jsx)(i,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,i,e)=>{e.d(i,{R:()=>l,x:()=>o});var t=e(6540);const s={},a=t.createContext(s);function l(n){const i=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function o(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),t.createElement(a.Provider,{value:i},n.children)}}}]);